
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Problem 1</title><meta name="generator" content="MATLAB 7.13"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2012-10-15"><meta name="DC.source" content="lab2.m"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head><body><div class="content"><h1>Problem 1</h1><!--introduction--><!--/introduction--><pre class="codeinput">print(<span class="string">'Problem 1.'</span>)
disp(sprintf(<span class="string">'\n'</span>));
ten_digits_of_accuracy =.5E-10;
<span class="comment">% a. log(1.9)  = log(1-(-0.9))</span>
<span class="comment">% To calculate log(1.9) x needs to be -0.9</span>
reqx = -0.9;
</pre><pre class="codeoutput">Problem 1.


</pre><p>b.</p><pre class="codeinput">xtrue = 0.64185388617239469;
k = 1;
<span class="keyword">while</span> abs(eq1(reqx, k) - xtrue) &gt; ten_digits_of_accuracy
    k = k + 1;
<span class="keyword">end</span>
xcalc = eq1(reqx, k);
print(<span class="string">'log(1.9) = log(1-(-0.9))'</span>);
disp(sprintf(<span class="string">'True value: %0.11f'</span>, xtrue));
disp(sprintf(<span class="string">'Calculated at %d (terms) iterations: %0.11f'</span>, k, xcalc));
</pre><pre class="codeoutput">log(1.9) = log(1-(-0.9))
True value: 0.64185388617
Calculated at 170 (terms) iterations: 0.64185388613
</pre><p>c. (x^(2*k - 1)/(2*k - 1)) To calculate log(1.9) x needs to be 0.9/2.9</p><pre class="codeinput">reqx = 0.9/2.9;
</pre><p>d.</p><pre class="codeinput">xtrue = 0.64185388617239469;
k = 1;
<span class="keyword">while</span> abs(eq2(reqx, k) - xtrue) &gt; ten_digits_of_accuracy;
    k = k + 1;
<span class="keyword">end</span>
xcalc = eq2(reqx, k);
print(xcalc);

print(<span class="string">'(x^(2*k - 1)/(2*k - 1))'</span>);
disp(sprintf(<span class="string">'True value: %0.11f'</span>, xtrue));
disp(sprintf(<span class="string">'Calculated at %d (terms) iterations: %0.11f'</span>, k, xcalc));
</pre><pre class="codeoutput">    0.6419

(x^(2*k - 1)/(2*k - 1))
True value: 0.64185388617
Calculated at 9 (terms) iterations: 0.64185388615
</pre><p>e. The second taylor seriese is better for approximating log(1.9) because it takes less iterations to get a value within 10 significant digits of accuracy. The second equations is faster because the exponent in the numerator is large and will cause the function to correct itself by less during each iteration which means it initially had a better estimate to start with.</p><p>2.</p><pre class="codeinput">disp(sprintf(<span class="string">'\n'</span>));
print(<span class="string">'Problem 2.'</span>)
disp(sprintf(<span class="string">'\n'</span>));
</pre><pre class="codeoutput">

Problem 2.


</pre><p>a. ((4 + x)^(-1/2) - 2) / x</p><pre class="codeinput">print(<span class="string">'f(x) = ((4 + x)^(-1/2) - 2) / x'</span>)
print(<span class="string">'f_fixed(x) = 1/(sqrt(4 + x) + 2);'</span>)
do_table(@eq2a, @eq2a_fixed)
disp(sprintf(<span class="string">'\n'</span>));

<span class="comment">% The first function adds a very small number to 4 and than takes the square root of the sum. When x because so small that 4 + x is rounded to 4 (because of the limitations with floating point numbers) sqrt(4+x) becomes equal to 0. The 'fixed' function removes the subtraction of the two nearly equal numbers and consequently removes the error.</span>
</pre><pre class="codeoutput">f(x) = ((4 + x)^(-1/2) - 2) / x
f_fixed(x) = 1/(sqrt(4 + x) + 2);
Table:
x 	 f(x) 	 	 (fixed) f(x)
0.1 	 0.2484567313 	 0.2484567313
0.01 	 0.2498439450 	 0.2498439450
0.001 	 0.2499843770 	 0.2499843770
0.0001 	 0.2499984375 	 0.2499984375
1e-05 	 0.2499998438 	 0.2499998438
1e-06 	 0.2499999843 	 0.2499999844
1e-07 	 0.2499999985 	 0.2499999984
1e-08 	 0.2499999763 	 0.2499999998
1e-09 	 0.2500000207 	 0.2500000000
1e-10 	 0.2500000207 	 0.2500000000
1e-11 	 0.2499778162 	 0.2500000000
1e-12 	 0.2500222251 	 0.2500000000
1e-13 	 0.2486899575 	 0.2500000000
1e-14 	 0.2220446049 	 0.2500000000
1e-15 	 0.0000000000 	 0.2500000000
1e-16 	 0.0000000000 	 0.2500000000
1e-17 	 0.0000000000 	 0.2500000000
1e-18 	 0.0000000000 	 0.2500000000
1e-19 	 0.0000000000 	 0.2500000000
1e-20 	 0.0000000000 	 0.2500000000


</pre><p>b. (1 - e^(-x))/x</p><pre class="codeinput">print(<span class="string">'f(x) = (1 - e^(-x))/x'</span>)
do_table(@eq2b, @eq2b_fixed)
disp(sprintf(<span class="string">'\n'</span>));

<span class="comment">% The first function was subtracting something very close to 1 from 1 itself. This caused a zero value to be in the numerator which caused the function to evaluate to zero. By using a taylor series we can use the expanded terms to make the numerator non-zero after subtraction.</span>
</pre><pre class="codeoutput">f(x) = (1 - e^(-x))/x
Table:
x 	 f(x) 	 	 (fixed) f(x)
0.1 	 0.9516258196 	 0.9048374180
0.01 	 0.9950166251 	 0.9900498337
0.001 	 0.9995001666 	 0.9990004998
0.0001 	 0.9999500017 	 0.9999000050
1e-05 	 0.9999950000 	 0.9999900000
1e-06 	 0.9999995000 	 0.9999990000
1e-07 	 0.9999999495 	 0.9999999000
1e-08 	 0.9999999939 	 0.9999999900
1e-09 	 0.9999999717 	 0.9999999990
1e-10 	 1.0000000827 	 0.9999999999
1e-11 	 1.0000000827 	 1.0000000000
1e-12 	 0.9999778783 	 1.0000000000
1e-13 	 1.0003109452 	 1.0000000000
1e-14 	 0.9992007222 	 1.0000000000
1e-15 	 0.9992007222 	 1.0000000000
1e-16 	 1.1102230246 	 1.0000000000
1e-17 	 0.0000000000 	 1.0000000000
1e-18 	 0.0000000000 	 1.0000000000
1e-19 	 0.0000000000 	 1.0000000000
1e-20 	 0.0000000000 	 1.0000000000


</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.13<br></p></div><!--
##### SOURCE BEGIN #####
%% Problem 1
%%
print('Problem 1.')
disp(sprintf('\n'));
ten_digits_of_accuracy =.5E-10;
% a. log(1.9)  = log(1-(-0.9))
% To calculate log(1.9) x needs to be -0.9
reqx = -0.9;
%%
% b.
xtrue = 0.64185388617239469;
k = 1;
while abs(eq1(reqx, k) - xtrue) > ten_digits_of_accuracy
    k = k + 1;
end
xcalc = eq1(reqx, k);
print('log(1.9) = log(1-(-0.9))');
disp(sprintf('True value: %0.11f', xtrue));
disp(sprintf('Calculated at %d (terms) iterations: %0.11f', k, xcalc));

%%
% c. (x^(2*k - 1)/(2*k - 1))
% To calculate log(1.9) x needs to be 0.9/2.9
reqx = 0.9/2.9;

%%
% d.
xtrue = 0.64185388617239469;
k = 1;
while abs(eq2(reqx, k) - xtrue) > ten_digits_of_accuracy;
    k = k + 1;
end
xcalc = eq2(reqx, k);
print(xcalc);

print('(x^(2*k - 1)/(2*k - 1))');
disp(sprintf('True value: %0.11f', xtrue));
disp(sprintf('Calculated at %d (terms) iterations: %0.11f', k, xcalc));

%%
% e. The second taylor seriese is better for approximating log(1.9) because it
% takes less iterations to get a value within 10 significant digits of
% accuracy. The second equations is faster because the exponent in the
% numerator is large and will cause the function to correct itself by less
% during each iteration which means it initially had a better estimate to start
% with.


%%
% 2.
disp(sprintf('\n'));
print('Problem 2.')
disp(sprintf('\n'));

%%
% a. ((4 + x)^(-1/2) - 2) / x
print('f(x) = ((4 + x)^(-1/2) - 2) / x')
print('f_fixed(x) = 1/(sqrt(4 + x) + 2);')
do_table(@eq2a, @eq2a_fixed)
disp(sprintf('\n'));

% The first function adds a very small number to 4 and than takes the square root of the sum. When x because so small that 4 + x is rounded to 4 (because of the limitations with floating point numbers) sqrt(4+x) becomes equal to 0. The 'fixed' function removes the subtraction of the two nearly equal numbers and consequently removes the error.
%%
% b. (1 - e^(-x))/x
print('f(x) = (1 - e^(-x))/x')
do_table(@eq2b, @eq2b_fixed)
disp(sprintf('\n'));

% The first function was subtracting something very close to 1 from 1 itself. This caused a zero value to be in the numerator which caused the function to evaluate to zero. By using a taylor series we can use the expanded terms to make the numerator non-zero after subtraction.

##### SOURCE END #####
--></body></html>
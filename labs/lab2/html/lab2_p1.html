
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Problem 1</title><meta name="generator" content="MATLAB 7.13"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2012-10-14"><meta name="DC.source" content="lab2_p1.m"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head><body><div class="content"><h1>Problem 1</h1><!--introduction--><!--/introduction--><p>a. log(1.9)  = log(1-(-0.9)) To calculate log(1.9) x needs to be -0.9</p><pre class="codeinput">reqx = -0.9;
</pre><p>b.</p><pre class="codeinput">digits_of_accuracy = 11;
xtrue = 0.64185388617239469;
k = 1;
<span class="keyword">while</span> abs(eq1(reqx, k) - xtrue) &gt; power(10, (-1) * digits_of_accuracy)
    k = k + 1;
<span class="keyword">end</span>
xcalc = eq1(reqx, k);
print(<span class="string">'log(1.9) = log(1-(-0.9))'</span>);
disp(sprintf(<span class="string">'True value: %0.11f'</span>, xtrue));
disp(sprintf(<span class="string">'Calculated at %d (terms) iterations: %0.11f'</span>, k, xcalc));
</pre><pre class="codeoutput">log(1.9) = log(1-(-0.9))
True value: 0.64185388617
Calculated at 184 (terms) iterations: 0.64185388616
</pre><p>c. (x^(2*k - 1)/(2*k - 1)) To calculate log(1.9) x needs to be 0.9/2.9</p><pre class="codeinput">reqx = 0.9/2.9;
</pre><p>d.</p><pre class="codeinput">digits_of_accuracy = 11;
xtrue = 0.64185388617239469;
k = 1;
<span class="keyword">while</span> abs(eq2(reqx, k) - xtrue) &gt; power(10, (-1) * digits_of_accuracy);
    k = k + 1;
<span class="keyword">end</span>
xcalc = eq2(reqx, k);
print(xcalc);

print(<span class="string">'(x^(2*k - 1)/(2*k - 1))'</span>);
disp(sprintf(<span class="string">'True value: %0.11f'</span>, xtrue));
disp(sprintf(<span class="string">'Calculated at %d (terms) iterations: %0.11f'</span>, k, xcalc));
</pre><pre class="codeoutput">    0.6419

(x^(2*k - 1)/(2*k - 1))
True value: 0.64185388617
Calculated at 10 (terms) iterations: 0.64185388617
</pre><p>e. The second taylor seriese is better for approximating log(1.9) because it takes less iterations to get a value within 10 significant digits of accuracy. The second equations is faster because the exponent in the numerator is large and will cause the function to correct itself by less during each iteration which means it initially had a better estimate to start with.</p><p class="footer"><br>
      Published with MATLAB&reg; 7.13<br></p></div><!--
##### SOURCE BEGIN #####
%% Problem 1
%%
% a. log(1.9)  = log(1-(-0.9))
% To calculate log(1.9) x needs to be -0.9
reqx = -0.9;
%%
% b.
digits_of_accuracy = 11;
xtrue = 0.64185388617239469;
k = 1;
while abs(eq1(reqx, k) - xtrue) > power(10, (-1) * digits_of_accuracy)
    k = k + 1;
end
xcalc = eq1(reqx, k);
print('log(1.9) = log(1-(-0.9))');
disp(sprintf('True value: %0.11f', xtrue));
disp(sprintf('Calculated at %d (terms) iterations: %0.11f', k, xcalc));

%%
% c. (x^(2*k - 1)/(2*k - 1))
% To calculate log(1.9) x needs to be 0.9/2.9
reqx = 0.9/2.9;

%%
% d.
digits_of_accuracy = 11;
xtrue = 0.64185388617239469;
k = 1;
while abs(eq2(reqx, k) - xtrue) > power(10, (-1) * digits_of_accuracy);
    k = k + 1;
end
xcalc = eq2(reqx, k);
print(xcalc);

print('(x^(2*k - 1)/(2*k - 1))');
disp(sprintf('True value: %0.11f', xtrue));
disp(sprintf('Calculated at %d (terms) iterations: %0.11f', k, xcalc));

%%
% e. The second taylor seriese is better for approximating log(1.9) because it
% takes less iterations to get a value within 10 significant digits of
% accuracy. The second equations is faster because the exponent in the
% numerator is large and will cause the function to correct itself by less
% during each iteration which means it initially had a better estimate to start
% with.

##### SOURCE END #####
--></body></html>